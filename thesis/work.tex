\chapter{Описание игры и целевая задача}

\section{Правила и особенности игры Каркассон}
Игра «Каркассон» (Carcassonne) является настольной стратегической игрой немецкого стиля (Eurogame), в которой игровой процесс строится на пошаговом выкладывании квадратов местности (тайлов) и размещении на них фишек подданных (миплов)~\cite{karna2012carcassonne}. Пример игрового процесса представлен на рисунке~\ref{fig:rules}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{carcassonne_rules.jpeg}
    \caption{Игровой процесс и выкладывание тайлов в Каркассоне}
    \label{fig:rules}
\end{figure}

Игровое пространство формируется динамически в процессе игры. Каждый новый тайл должен быть выложен по правилам топологической связности: грани выкладываемого квадрата должны логически продолжать объекты на уже лежащих на столе квадратах (дорога должна соединяться с дорогой, город с городом, поле с полем).

\section{Проблематика алгоритмического решения}
С точки зрения теории игр, Каркассон представляет собой стохастическую игру с полной информацией. Однако разработка оптимальной стратегии для искусственного агента сталкивается с рядом существенных трудностей:

\begin{itemize}
    \item \textbf{Размер пространства состояний.} В базовой версии игры участвуют 72 тайла, которые могут быть выложены в различных конфигурациях. Количество допустимых позиций возрастает экспоненциально с каждым ходом~\cite{heyden2009implementing}.
    \item \textbf{NP-трудность.} Задача поиска оптимального размещения тайлов математически эквивалентна обобщенной задаче подбора краев (Edge-Matching Puzzle), которая в общем случае является NP-полной.
    \item \textbf{Проблема горизонта планирования.} Из-за механизма подсчета очков (в частности, отложенного вознаграждения за владение полями в самом конце игры) классические жадные алгоритмы (Greedy algorithms) принимают локально оптимальные, но глобально убыточные решения~\cite{sutton2018reinforcement}.
\end{itemize}

\chapter{Математическая модель игры}

\section{Формализация игровых объектов и правил}
Для перевода правил настольной игры в программную логику необходимо формализовать основные компоненты системы.

\subsection{Тайл как информационный объект}
Центральным объектом системы является тайл --- квадрат местности, разделенный на функциональные зоны. Следуя подходу К. Хейден~\cite{heyden2009implementing}, каждый тайл описывается как структура, содержащая информацию о четырех своих сторонах (север, юг, запад, восток) и центральной области. 
Каждая сторона тайла имеет определенный тип (поле, город, дорога), что обеспечивает топологическую связность при стыковке: сторона $S_1$ тайла $T_1$ может быть соединена со стороной $S_2$ тайла $T_2$ только если их типы идентичны ($type(S_1) = type(S_2)$).

\subsection{Графовое представление игрового поля}
Для программной реализации игровое поле моделируется как динамический планарный граф $G = (V, E)$, где:
\begin{itemize}
    \item $V$ --- множество вершин, представляющих собой элементарные сегменты тайлов.
    \item $E$ --- множество ребер, соединяющих сегменты одного типа как внутри тайла, так и на границах смежных тайлов.
\end{itemize}
Граф $G$ является динамическим, так как на каждом ходу $k$ в него добавляется подграф $G_{tile}$ нового тайла, и строятся ребра $E_{match}$, связывающие его с существующей структурой поля.

При добавлении нового тайла на поле граф $G$ модифицируется: добавляются новые вершины и строятся новые ребра, объединяющие смежные сегменты. Пример графового представления игрового поля представлен на рисунке~\ref{fig:graph_repr}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{graph_repr.png}
    \caption{Графовое представление игрового поля}
    \label{fig:graph_repr}
\end{figure}

\section{Алгоритмическая реализация связности}
Одной из ключевых задач игрового движка является отслеживание завершенности объектов (городов, дорог) и распределение очков между игроками.

\subsection{Использование системы непересекающихся множеств (DSU)}
Для эффективного управления компонентами связности в графе $G$ применяется структура данных \textit{Disjoint-Set Union} (DSU) с оптимизациями по рангу и сжатию путей. 
Каждый сегмент тайла принадлежит определенному множеству $S \in \mathcal{S}$. Операция $Find(v)$ позволяет определить, к какому логическому объекту (например, конкретному городу) принадлежит вершина $v$. Операция $Union(u, v)$ выполняется при стыковке тайлов, объединяя сегменты в единый игровой объект.

Использование DSU позволяет решать следующие задачи за амортизированное время $O(\alpha(n))$~\cite{knuth2000dancing}:
\begin{itemize}
    \item \textbf{Проверка завершенности:} Объект считается завершенным, если у всех входящих в него сегментов нет свободных (не пристыкованных) сторон.
    \item \textbf{Определение владельца:} Подсчет количества миплов каждого игрока в рамках одной компоненты связности.
    \item \textbf{Мгновенный пересчет очков:} Обновление игрового состояния сразу после добавления ребра в граф.
\end{itemize}

\chapter{Разработка гибридного алгоритма оптимизации}

\section{Архитектурное разделение слоев}
Архитектура программного комплекса построена на принципе полного разделения ответственности между правилами игры и стратегическим интеллектом. Это разделение реализовано через два ключевых уровня:

\subsection{Логический уровень (Logic Layer)}
Игровой движок, написанный на языке Python, инкапсулирует в себе:
\begin{itemize}
    \item \textbf{Справочник тайлов:} Описание всех 72 плиток базового набора.
    \item \textbf{Геометрический валидатор:} Проверка допустимости координат и ориентации тайла.
    \item \textbf{Расчетный модуль:} Учет очков и мониторинг завершенности объектов через DSU.
\end{itemize}
Logic Layer функционирует как изолированный сервер, передающий информацию только по стандартизированным протоколам.

\subsection{Стратегический уровень (Strategy Layer)}
Верхнеуровневый агент, использующий локальную Large Language Model (LLM). Он не знает правил «в жестком коде», но получает описание текущей ситуации и доступные инструменты (tools) через интерфейс сервера.

\section{Реализация Model Context Protocol (MCP)}
Для взаимодействия слоев выбран протокол \textit{Model Context Protocol} (MCP). Это позволяет превратить игровой движок в «умную периферию» для ИИ.

\subsection{Компоненты MCP-сервера}
Разработанный сервер предоставляет следующие абстракции:
\begin{itemize}
    \item \textbf{Resources:} Текстовое описание текущего состояния поля и списка оставшихся тайлов в колоде.
    \item \textbf{Tools:} Функции \texttt{get\_legal\_moves} (возвращает список координат и поворотов), \texttt{place\_tile} (совершает ход) и \texttt{get\_score}.
    \item \textbf{Prompts:} Предустановленные шаблоны системных промптов, которые подготавливают LLM к роли профессионального игрока в Каркассон.
\end{itemize}
Взаимодействие осуществляется через JSON-RPC 2.0, что обеспечивает слабую связанность компонентов и позволяет в будущем легко заменить стратегический уровень (например, использовать другую модель LLM) без изменения кода игрового движка.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{architecture_schema.jpeg}
    \caption{Схема архитектуры решения (Logic Layer и Strategy Layer)}
    \label{fig:arch_schema}
\end{figure}

\section{Интеграция LLM и эвристики}
В основе стратегического уровня лежит использование локальной языковой модели (Ollama), которая выступает в роли интеллектуального советника.

\subsection{Методология Tree of Thoughts (ToT)}
Для решения задачи планирования применяется фреймворк \textit{Tree of Thoughts}~\cite{yao2024tree}. В отличие от стандартного пошагового вывода, ToT позволяет модели:
\begin{itemize}
    \item Генерировать несколько вариантов хода («мыслей»).
    \item Оценивать каждый вариант на предмет долгосрочной выгоды (Self-Evaluation).
    \item Выбирать наиболее перспективную ветвь развития или выполнять бэктрекинг в случае обнаружения тупиковых стратегий.
\end{itemize}

\subsection{Вербальное подкрепление через Reflexion}
Для минимизации ошибок и улучшения качества ходов без дорогостоящего дообучения модели внедрен подход \textit{Reflexion}~\cite{shinn2023reflexion}. После каждого совершенного хода или в случае неудачного исхода партии, Logic Layer формирует текстовый отчет об ошибках, который передается модели. Модель выполняет «вербальную рефлексию», записывая выводы в оперативную память контекста, что повышает точность последующих решений.

\section{Гибридный поиск и оптимизация}
Хотя LLM способна к высокоуровневому планированию, она может допускать ошибки в точных расчетах. Для компенсации этого разработана гибридная модель:
\begin{itemize}
    \item \textbf{MCTS как фильтр:} Традиционный Monte Carlo Tree Search~\cite{ameneyro2020playing} выполняет быструю оценку терминальных состояний для отсечения заведомо проигрышных ходов.
    \item \textbf{LLM как селектор:} Языковая модель выбирает финальный ход из 3-5 лучших вариантов, предложенных MCTS, основываясь на стратегическом контексте, который трудно формализовать в чистой математике (например, психологическое давление на оппонента).
\end{itemize}
Такой симбиоз позволяет достичь баланса между вычислительной точностью и стратегической гибкостью.
