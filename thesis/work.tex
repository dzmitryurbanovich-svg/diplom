\chapter{Описание игры и целевая задача}

\section{Правила и структура игрового процесса}
Настольная игра «Каркассон» (Carcassonne) представляет собой классический пример тайлоукладочной стратегии немецкой школы. Игровой процесс основан на пошаговом расширении игрового поля путем размещения квадратных плиток местности (тайлов)~\cite{karna2012carcassonne}. Каждый ход игрока состоит из трех последовательных фаз:

\begin{enumerate}
    \item \textbf{Размещение тайла.} Игрок вытягивает случайный тайл из закрытой колоды и должен разместить его на поле так, чтобы он граничил хотя бы с одним уже выложенным тайлом. При этом должно соблюдаться правило топологической связности: стороны квадратов должны логически продолжать друг друга (дорога к дороге, город к городу, поле к полю).
    \item \textbf{Размещение подданного (мипла).} После размещения тайла игрок имеет право выставить одну фишку подданного на один из объектов только что выложенного тайла (город, дорогу, монастырь или поле), при условии, что этот объект еще не занят другим игроком.
    \item \textbf{Подсчёт очков.} Если в результате хода объект (город, дорога или монастырь) становится завершенным, владельцы этого объекта получают очки, а задействованные миплы возвращаются в запас игроков.
\end{enumerate}

Пример визуализации базовых правил представлен на рисунке~\ref{fig:rules}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{carcassonne_rules.jpeg}
    \caption{Игровой процесс и правила выкладывания тайлов в Каркассоне}
    \label{fig:rules}
\end{figure}

\section{Особенности и стратегическая глубина}
Несмотря на кажущуюся простоту правил, «Каркассон» обладает высокой стратегической глубиной, обусловленной следующими особенностями:

\begin{itemize}
    \item \textbf{Экономика ресурсов.} У каждого игрока ограниченное количество миплов (всего 7). Ошибка в планировании может привести к «зависанию» ресурсов на незавершенных объектах, что лишает игрока возможности занимать новые выгодные позиции.
    \item \textbf{Конкуренция и кооперация.} Правила запрещают ставить мипла на уже занятый объект, однако игроки могут соединять свои объекты в процессе игры. Это порождает сложные сценарии борьбы за контроль над крупными городами или полями, где побеждает тот, у кого больше миплов в итоговой структуре.
    \item \textbf{Динамическое поле.} Отсутствие фиксированных границ поля требует от игрока не только тактического расчета на текущий ход, но и пространственного воображения для создания «ловушек» оппоненту (например, создание условий, при которых оппоненту крайне сложно завершить свой город).
\end{itemize}

\section{Проблематика алгоритмического решения}
Для разработки искусственного интеллекта (ИИ), способного конкурировать с опытным игроком, необходимо преодолеть ряд вычислительных и логических барьеров~\cite{heyden2009implementing}:

\begin{itemize}
    \item \textbf{Комбинаторная сложность.} Пространство состояний игры крайне велико. Хотя в колоде всего 72 тайла, количество возможных конфигураций игрового поля при каждом новом ходе растет экспоненциально.
    \item \textbf{Стохастичность и неопределенность.} Игрок не знает, какой тайл выпадет следующим. Это делает невозможным применение классического алгоритма Minimax в чистом виде и требует использования методов статистического моделирования.
    \item \textbf{Проблема «Слабого звена» эвристик.} Традиционные эвристические алгоритмы (Star2.5, Greedy) хорошо справляются с накоплением очков «здесь и сейчас», но не способны оценить стратегическую важность «пустых» ходов, направленных на блокировку соперника или подготовку к захвату поля в конце игры.
    \item \textbf{Branching Factor во время поиска.} В отличие от шахмат, где количество ходов ограничено правилами фигур, в Каркассоне количество допустимых позиций для тайла в середине игры может достигать 50-100 вариантов, каждый из которых имеет 4 варианта поворота и 1-8 вариантов размещения мипла.
\end{itemize}

Именно на стыке этих проблем возникает необходимость в создании гибридных моделей, сочетающих точность математического поиска (MCTS) и высокоуровневую логику языковых моделей (LLM).

\chapter{Математическая модель игры}

\section{Формализация игровых объектов и правил}
Для перевода правил настольной игры в программную логику необходимо формализовать основные компоненты системы.

\subsection{Тайл как информационный объект}
Центральным объектом системы является тайл --- квадрат местности, разделенный на функциональные зоны. Следуя подходу К. Хейден~\cite{heyden2009implementing}, каждый тайл описывается как структура, содержащая информацию о четырех своих сторонах (север, юг, запад, восток) и центральной области. 
Каждая сторона тайла имеет определенный тип (поле, город, дорога), что обеспечивает топологическую связность при стыковке: сторона $S_1$ тайла $T_1$ может быть соединена со стороной $S_2$ тайла $T_2$ только если их типы идентичны ($type(S_1) = type(S_2)$).

\subsection{Графовое представление игрового поля}
Для программной реализации игровое поле моделируется как динамический планарный граф $G = (V, E)$, где:
\begin{itemize}
    \item $V$ --- множество вершин, представляющих собой элементарные сегменты тайлов.
    \item $E$ --- множество ребер, соединяющих сегменты одного типа как внутри тайла, так и на границах смежных тайлов.
\end{itemize}
Граф $G$ является динамическим, так как на каждом ходу $k$ в него добавляется подграф $G_{tile}$ нового тайла, и строятся ребра $E_{match}$, связывающие его с существующей структурой поля.

При добавлении нового тайла на поле граф $G$ модифицируется: добавляются новые вершины и строятся новые ребра, объединяющие смежные сегменты. Пример графового представления игрового поля представлен на рисунке~\ref{fig:graph_repr}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{graph_repr.png}
    \caption{Графовое представление игрового поля}
    \label{fig:graph_repr}
\end{figure}

\section{Алгоритмическая реализация связности}
Одной из ключевых задач игрового движка является отслеживание завершенности объектов (городов, дорог) и распределение очков между игроками.

\subsection{Использование системы непересекающихся множеств (DSU)}
Для эффективного управления компонентами связности в графе $G$ применяется структура данных \textit{Disjoint-Set Union} (DSU) с оптимизациями по рангу и сжатию путей. 
Каждый сегмент тайла принадлежит определенному множеству $S \in \mathcal{S}$. Операция $Find(v)$ позволяет определить, к какому логическому объекту (например, конкретному городу) принадлежит вершина $v$. Операция $Union(u, v)$ выполняется при стыковке тайлов, объединяя сегменты в единый игровой объект.

Использование DSU позволяет решать следующие задачи за амортизированное время $O(\alpha(n))$~\cite{knuth2000dancing}:
\begin{itemize}
    \item \textbf{Проверка завершенности:} Объект считается завершенным, если у всех входящих в него сегментов нет свободных (не пристыкованных) сторон.
    \item \textbf{Определение владельца:} Подсчет количества миплов каждого игрока в рамках одной компоненты связности.
    \item \textbf{Мгновенный пересчет очков:} Обновление игрового состояния сразу после добавления ребра в граф.
\end{itemize}

\chapter{Разработка гибридного алгоритма оптимизации}

\section{Архитектурное разделение слоев}
Архитектура программного комплекса построена на принципе полного разделения ответственности между правилами игры и стратегическим интеллектом. Это разделение реализовано через два ключевых уровня:

\subsection{Логический уровень (Logic Layer)}
Игровой движок, написанный на языке Python, инкапсулирует в себе:
\begin{itemize}
    \item \textbf{Справочник тайлов:} Описание всех 72 плиток базового набора.
    \item \textbf{Геометрический валидатор:} Проверка допустимости координат и ориентации тайла.
    \item \textbf{Расчетный модуль:} Учет очков и мониторинг завершенности объектов через DSU.
\end{itemize}
Logic Layer функционирует как изолированный сервер, передающий информацию только по стандартизированным протоколам.

\subsection{Стратегический уровень (Strategy Layer)}
Верхнеуровневый агент, использующий локальную Large Language Model (LLM). Он не знает правил «в жестком коде», но получает описание текущей ситуации и доступные инструменты (tools) через интерфейс сервера.

\section{Реализация Model Context Protocol (MCP)}
Для взаимодействия слоев выбран протокол \textit{Model Context Protocol} (MCP). Это позволяет превратить игровой движок в «умную периферию» для ИИ.

\subsection{Компоненты MCP-сервера}
Разработанный сервер предоставляет следующие абстракции:
\begin{itemize}
    \item \textbf{Resources:} Текстовое описание текущего состояния поля и списка оставшихся тайлов в колоде.
    \item \textbf{Tools:} Функции \texttt{get\_legal\_moves} (возвращает список координат и поворотов), \texttt{place\_tile} (совершает ход) и \texttt{get\_score}.
    \item \textbf{Prompts:} Предустановленные шаблоны системных промптов, которые подготавливают LLM к роли профессионального игрока в Каркассон.
\end{itemize}
Взаимодействие осуществляется через JSON-RPC 2.0, что обеспечивает слабую связанность компонентов и позволяет в будущем легко заменить стратегический уровень (например, использовать другую модель LLM) без изменения кода игрового движка.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{architecture_schema.jpeg}
    \caption{Схема архитектуры решения (Logic Layer и Strategy Layer)}
    \label{fig:arch_schema}
\end{figure}

\section{Интеграция LLM и эвристики}
В основе стратегического уровня лежит использование локальной языковой модели (Ollama), которая выступает в роли интеллектуального советника.

\subsection{Методология Tree of Thoughts (ToT)}
Для решения задачи планирования применяется фреймворк \textit{Tree of Thoughts}~\cite{yao2024tree}. В отличие от стандартного пошагового вывода, ToT позволяет модели:
\begin{itemize}
    \item Генерировать несколько вариантов хода («мыслей»).
    \item Оценивать каждый вариант на предмет долгосрочной выгоды (Self-Evaluation).
    \item Выбирать наиболее перспективную ветвь развития или выполнять бэктрекинг в случае обнаружения тупиковых стратегий.
\end{itemize}

\subsection{Вербальное подкрепление через Reflexion}
Для минимизации ошибок и улучшения качества ходов без дорогостоящего дообучения модели внедрен подход \textit{Reflexion}~\cite{shinn2023reflexion}. После каждого совершенного хода или в случае неудачного исхода партии, Logic Layer формирует текстовый отчет об ошибках, который передается модели. Модель выполняет «вербальную рефлексию», записывая выводы в оперативную память контекста, что повышает точность последующих решений.

\section{Гибридный поиск и оптимизация}
Хотя LLM способна к высокоуровневому планированию, она может допускать ошибки в точных расчетах. Для компенсации этого разработана гибридная модель:
\begin{itemize}
    \item \textbf{MCTS как фильтр:} Традиционный Monte Carlo Tree Search~\cite{ameneyro2020playing} выполняет быструю оценку терминальных состояний для отсечения заведомо проигрышных ходов.
    \item \textbf{LLM как селектор:} Языковая модель выбирает финальный ход из 3-5 лучших вариантов, предложенных MCTS, основываясь на стратегическом контексте, который трудно формализовать в чистой математике (например, психологическое давление на оппонента).
\end{itemize}
Такой симбиоз позволяет достичь баланса между вычислительной точностью и стратегической гибкостью.
